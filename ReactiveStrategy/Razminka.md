**1.**
Предполагаю, что все зависит от уровня абстракции.
   Если смотреть как на клиент серверную архитектуру, то мы увидим 3 компонента
   Front
   Middle (API)
   Back (BD)

или 5, если сети считать отдельными компонентом.

Но, если посмотреть более детально и посмотреть на Front как на отдельную подсистему, то его компонентами будет:
Поле Фамилия
Поле Имя
Поле Отчество
Поле Дата
Поле (Какой-то документ)
Кнопка Отправить

Сеть (Между фронтов и мидлом)
Сервер
Сеть (между сервером и БД)
База Данных

**2.** 
Посмотри на схему и определи количество интеграций в этой системе. Чтобы тебе было проще, можешь выделять на картинке и прислать в качестве ответа картинку с выделенными связями.

Все зависит от уровня абстракции который мы будем использовать.
Например 2, Между Front и Middle(API) и между Middle(API) и BD.

Но также, можно предположить, что между каждым отдельным полем на Front есть отдельная интеграция с сервером. (Например, мы вводим в поле "какой-то документ" (серия №) данные и происходит валидация конкретного поля, возможно она проходит на стороне клиента, но также возможно она проходит на стороне сервера). Так же и календарь вероятно может иметь отдельную интеграцию, в этом случае получается 7.

**3.** 
Если слово "ввод" подразумевает введение данных без отправки, то:
   Если у поля отсутствует строгая маска, которая ограничивает ввод символов, могу предположить, что много, (предположительно i-знаков которое может вместить в себя это поле, или n-знаков которыми ограничил ввод разработчик на клиенте). В некоторых случаях этот параметр можно посмотреть через devtools в дереве DOM у соответствующего поля (указывается не всегда).
   Если слово "ввод" подразумевает введение данных и отправить их, то:
   В дополнении гипотезы (без отправки) добавлю, ограничения заложенные на серверной или в БД.
   Думаю, что эту границу можно нащупать только опытным путем, если этот параметр не указан в документации (в которую мы смотрим первым делом), и общепринятые практики. Та рекомендация, про которую я читал, не стоит ограничивать пользователя.

**4.**
1. Изучить документацию, на наличие границы, проверить их.
2. Если документация отсутствует, введу корректное Отчество и проверю что поле вообще работает.
3. Оставить поле пустым для проверки отсутствия нижней границы. Если пустая строка выдает ошибку добавляем по одному знаку, чтобы нащупать минимальную границу. Если нижняя граница отсутствует переходим к проверке верхней границы.
4. Для проверки верхней границы, можно было бы взять какое-то общее принятое число для таких полей, (а у Назиной кажется читал, что она говорила пользователя не стоит ограничивать в этом), по этому, для первой проверки возьму например 60 знаков, если поле его примет, буду поэтапно увеличивать. Для этого буду использовать инструмент генерации строки (например perlclip). Если удастся найти придел на ввод, буду использовать метода бисекционного деления. Полученный результат разделю пополам, и проверю 1 половину, если предел в ней, то буду работать с ней и повторно делить, если проблема не в ней, буду работать аналогично со второй половиной. Это проверка границы на клиенте. По необходимости, с той же логикой приступлю к поиску границ на сервере и в базе данных.
   Примечание:
   Если система выдаст осмысленную ошибку вида «Слишком длинное поле» — это ошибка на сервере. Если ошибка необработанная — скорее всего, на сервере границы нет, и найдена граница в базе.
   5 Так же, в зависимости от реализации продукта, возможно найти какую-то информацию в логах сообщение об ошибке.